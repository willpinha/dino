{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction &amp; Installation","text":"<p>Dino is a lightweight HTTP library that contains utilities compatible with the <code>net/http</code> package. If you want to work directly with <code>net/http</code> and the standard library, without relying on abstractions (third-party routers, frameworks, etc.), but don't want to implement common functionalities from scratch, Dino is the right library for you</p> <p>This documentation contains guides for functionalities that you might need for your project but that are not directly implemented in Dino (such as database access, monitoring, dependency injection, etc.). This way, you'll get an idea of \u200b\u200bhow to develop an application in the Dino/Go style</p> <p>We also provide some applications made with Dino so you can get inspired!</p> <p>Note</p> <p>This documentation assumes you already have some experience with <code>net/http</code>. If you don't have it, check the <code>net/http</code> cheat sheet for a better understanding and context</p>"},{"location":"#philosophy","title":"Philosophy","text":"<p>Dino doesn't try to be the magic solution that solves all your problems. Instead, it provides a thin layer built on top of <code>net/http</code> for functionalities commonly needed when building applications</p> <p>It also follows the Go philosophy, which is to maintain simplicity and not apply breaking changes or major versions all the time. This makes Dino an easy-to-use and stable library in the long term</p>"},{"location":"#installation","title":"Installation","text":"<p>Want to try Dino? Go get the package below and start reading the next sections of this documentation</p> <pre><code>go get github.com/willpinha/dino\n</code></pre>"},{"location":"cheat-sheet/net-http/","title":"<code>net/http</code> Cheat sheet","text":""},{"location":"database/document-based/","title":"Document-based databases","text":""},{"location":"database/getting-started/","title":"Getting started","text":""},{"location":"database/relational/","title":"Relational databases","text":""},{"location":"guides/monitoring-with-grafana/","title":"Monitoring with Grafana","text":""},{"location":"middlewares/access-log/","title":"AccessLogMiddleware","text":""},{"location":"middlewares/recover/","title":"RecoverMiddleware","text":""},{"location":"the-basics/error-handling/","title":"Error handling","text":"<p>Dino has a centralized error handling logic. Errors returned by the handlers are automatically processed, which greatly simplifies error handling</p> <p>There are two possibilities for returning an error in a handler: an error of type <code>dino.Error</code>, or any other error that is not of that type. Below are two examples of handlers that demonstrate these two possibilities:</p> <pre><code>func KnownErrorHandler() dino.Handler {\n    return func(w http.ResponseWriter, r *http.Request) error {\n        return dino.NewError(http.StatusBadRequest, \"invalid input\")\n    }\n}\n\nfunc UnknownErrorHandler() dino.Handler {\n    return func(w http.ResponseWriter, r *http.Request) error {\n        return errors.New(\"database error\")\n    }\n}\n</code></pre>"},{"location":"the-basics/error-handling/#response-format","title":"Response format","text":"<p>When we return an error of type <code>dino.Error</code>, it is automatically serialized to a JSON object in the response body. This standardizes the response format for all errors that your application returns</p> <p>This error response contains the following fields:</p> Field Required? Description <code>code</code> Yes The status code of the response <code>message</code> Yes A descriptive message about the error <code>details</code> No Additional information about the error (any JSON serializable type) <p>When we return an error that is not of type <code>dino.Error</code>, Dino generates a generic internal server error response with status code 500. This prevents unhandled errors from being sent in the response, which could lead to leaks of sensitive data (e.g. database information)</p> <p>Tip</p> <p>Ideally, all errors returned by a handler are of type <code>dino.Error</code></p> <p>This will force you to validate all types of errors that may occur in your handler, which results in greater control and transparency regarding errors and data that are returned to clients</p>"},{"location":"the-basics/error-handling/#creating-instances-of-dinoerror","title":"Creating instances of <code>dino.Error</code>","text":"<p>The correct way to create new instances of <code>dino.Error</code> is through the <code>dino.NewError</code> function. In addition to passing the status code and message, we can also pass any <code>dino.ErrorOption</code>:</p> Option Description <code>dino.WithDetails</code> Additional details. Ideal for when the message is insufficient to describe the error. It can be of any type that is serializable to JSON <code>dino.WithInternalError</code> An internal error that caused the error to be returned. This internal error is not serialized in the response, but can be used for logging or debugging purposes <code>dino.WithoutLog</code> Indicates that this error should not be logged. By default, all errors are logged"},{"location":"the-basics/error-handling/#organizing-errors-in-your-project","title":"Organizing errors in your project","text":"<p>Here we define some examples of best practices for you to organize the different types of errors in your project. Note that these examples are not mandatory; you can come up with your own solutions and patterns if they make sense for your project</p>"},{"location":"the-basics/error-handling/#functions-that-return-dinoerror","title":"Functions that return <code>dino.Error</code>","text":"<p>You can create functions that return <code>dino.Error</code> to standardize the response format for a particular type of error</p> <p>Example</p> <p>We define a generic <code>NotFound</code> function, which is used whenever a resource on your server could not be found</p> <pre><code>func NotFound() dino.Error {\n    return dino.NewError(http.StatusNotFound, \"Resource not found\")\n}\n</code></pre> <p>We can also pass an integer as a parameter, representing the ID of the resource that was not found</p> <pre><code>func IdentifierNotFound(id int) dino.Error {\n    return dino.NewError(http.StatusNotFound, fmt.Sprintf(\"ID %d not found\", id))\n}\n</code></pre> <p>We can then call this function in our handlers, instead of directly calling <code>dino.NewError</code></p> <pre><code>func GetUserHandler() dino.Handler {\n    return func(w http.ResponseWriter, r *http.Request) error {\n        userID := 123\n\n        return IdentifierNotFound(userID)\n    }\n}\n</code></pre>"},{"location":"the-basics/error-handling/#grouping-error-functions-into-a-single-package","title":"Grouping error functions into a single package","text":"<p>Your project may have multiple functions that return <code>dino.Error</code>. To organize them, you can define them in a common package, separating them into files within that package</p> <p>Example</p> <p>Let's say we have a separate directory structure divided into <code>cmd</code>, <code>internal</code>, and <code>pkg</code>. Inside <code>internal</code>, we have a <code>errors</code> package where we will store all the errors from our project</p> <pre><code>.\n\u251c\u2500\u2500 cmd\n\u251c\u2500\u2500 internal\n\u2502   \u2514\u2500\u2500 errors\n\u2502       \u251c\u2500\u2500 http.go\n\u2502       \u2514\u2500\u2500 users.go\n\u2514\u2500\u2500 pkg\n</code></pre> <p>The <code>http.go</code> file will have generic HTTP errors (not found, bad request, etc.)</p> http.go<pre><code>package errors\n\nfunc NotFound() dino.Error {\n    return dino.NewError(http.StatusNotFound, \"Resource not found\")\n}\n\nfunc BadRequest() dino.Error {\n    return dino.NewError(\n        http.StatusBadRequest,\n        \"There is something wrong with your request\",\n        dino.WithoutLog(),\n    )\n}\n</code></pre> <p>And the <code>users.go</code> file will have errors specifically related to users</p> users.go<pre><code>package errors\n\nfunc UserIsBlocked(username string) dino.Error {\n    return dino.NewError(\n        http.StatusForbidden,\n        fmt.Sprintf(\"User %s is blocked\", username),\n        dino.WithDetails(\"Please, contact the HR for more information\"),\n    )\n}\n</code></pre>"},{"location":"the-basics/handlers-routing/","title":"Handlers &amp; Routing","text":""},{"location":"the-basics/handlers-routing/#handlers","title":"Handlers","text":"<p>Handlers (a.k.a. Controllers) represents the core mechanism for processing HTTP requests and returning HTTP responses to the clients</p> <p>Similar to the <code>http.HandlerFunc</code> type of <code>net/http</code>, a handler in Dino is a function, with the difference that this function returns an error. See below for an example of a handler:</p> <pre><code>func MyHandler() dino.Handler {\n    return func(w http.ResponseWriter, r *http.Request) error {\n        // Handler logic here\n        return nil\n    }\n}\n</code></pre> <p>Defining a custom handler that returns an error is a very common pattern because it simplifies error handling, as we will see in the following sections. This pattern is used, for example, on Fiber and Echo handlers</p>"},{"location":"the-basics/handlers-routing/#routing","title":"Routing","text":"<p>Dino's handlers implement the <code>http.Handler</code> interface, and therefore can be used anywhere that interface is used. An example of this is in <code>http.ServeMux</code>:</p> <pre><code>mux := http.NewServeMux()\n\nmux.Handle(\"GET /my/path\", MyHandler())\nmux.Handle(\"POST /another/path\", AnotherHandler())\n</code></pre> <p>In fact, <code>http.ServeMux</code> is the ideal multiplexer (router) to use with Dino. This is because many of Dino's features are built upon the functionalities that <code>http.ServeMux</code> provides. Besides, it's part of the standard library and therefore a very stable router</p>"},{"location":"the-basics/logging/","title":"Logging","text":""},{"location":"the-basics/middlewares/","title":"Middlewares","text":""},{"location":"the-basics/requests/","title":"Requests","text":"<p>Dino provides several utilities to help you easily extract and validate data from your requests. This request data can come from the URL (path &amp; query parameters), the body, or the headers. Below you will see how to obtain and validate the data from each of these sources</p>"},{"location":"the-basics/requests/#reading-the-url-path-query-parameters","title":"Reading the URL (path &amp; query parameters)","text":"<p>The <code>dino.Param</code> type represents parameters that come from the URL path (e.g. <code>/users/{id}</code>) or query string (e.g. <code>?name=will</code>).</p>"},{"location":"the-basics/requests/#path-parameters","title":"Path parameters","text":""},{"location":"the-basics/requests/#query-parameters","title":"Query parameters","text":"<pre><code>func MyHandler() dino.Handler {\n    return func(w http.ResponseWriter, r *http.Request) error {\n        id, err := dino.NewPathParam(r, \"id\").Int()\n        if err != nil {\n            return err\n        }\n\n        name := dino.NewPathParam(r, \"name\").String()\n\n        return nil\n    }\n}\n</code></pre> Function Description <code>NewPathParam</code> <code>NewQueryParam</code> <code>NewDefaultQueryParam</code> <code>NewRequiredQueryParam</code>"},{"location":"the-basics/requests/#reading-the-body","title":"Reading the body","text":""},{"location":"the-basics/requests/#reading-headers","title":"Reading headers","text":""},{"location":"the-basics/responses/","title":"Responses","text":""},{"location":"the-basics/testing/","title":"Testing","text":""}]}